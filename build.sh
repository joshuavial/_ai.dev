#!/usr/bin/env bash

# _ai.dev Build System
# This script replaces setup.sh and provides:
# 1. Three-tier resource override system (_ai > ~/_ai > _ai.dev)
# 2. Auto-generation of provider files (CLAUDE.md, AGENTS.md, GEMINI.md)
# 3. Merged .claude/ folder building
# 4. Original setup.sh functionality (.gitignore, .wt.conf, etc.)

set -e  # Exit on error

# ============================================
# PATHS AND GLOBALS
# ============================================

SCRIPT_DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )"
PARENT_DIR="$(dirname "$SCRIPT_DIR")"
USER_AI="$HOME/_ai"
REPO_AI="$PARENT_DIR/_ai"
DEFAULT_AI="$SCRIPT_DIR"

# Resource types to process
RESOURCE_TYPES=("workflows" "protocols" "agents" "commands" "skills")

# Track if any changes were made
CHANGES_MADE=false

# ============================================
# CONFIGURATION LOADING
# ============================================

# Default configuration
BUILD_CLAUDE=true
BUILD_AGENTS=true
BUILD_GEMINI=true
INCLUDE_WORKFLOWS=true
INCLUDE_PROTOCOLS=true
INCLUDE_AGENTS=true
INCLUDE_COMMANDS=true
INCLUDE_SKILLS=true
OUTPUT_DIR="."
CLAUDE_OUTPUT="CLAUDE.md"
AGENTS_OUTPUT="AGENTS.md"
GEMINI_OUTPUT="GEMINI.md"
COMMIT_GENERATED=false
BUILD_CLAUDE_FOLDERS=true
CLAUDE_DIR=".claude"
SHOW_OVERRIDE_MARKERS=true
OVERRIDE_MARKER_REPO="[OVERRIDE: repo]"
OVERRIDE_MARKER_USER="[OVERRIDE: user]"
VERBOSE=false
SHOW_DIFF=false

# Load configuration files in precedence order
load_config() {
    local config_files=(
        "$DEFAULT_AI/_ai.dev.conf"           # System defaults
        "$USER_AI/_ai.dev.conf"              # User-global
        "$REPO_AI/_ai.dev.conf"              # Repo-specific
    )

    for config_file in "${config_files[@]}"; do
        if [ -f "$config_file" ]; then
            log_verbose "Loading config: $config_file"
            # shellcheck source=/dev/null
            source "$config_file"
        fi
    done
}

# ============================================
# UTILITY FUNCTIONS
# ============================================

log_verbose() {
    if [ "$VERBOSE" = "true" ]; then
        echo "$@"
    fi
}

log_info() {
    echo "$@"
}

log_success() {
    echo "  ✓ $@"
}

log_warning() {
    echo "  ⚠️  $@"
}

log_error() {
    echo "  ❌ $@" >&2
}

# ============================================
# GITIGNORE MANAGEMENT
# ============================================

add_to_gitignore() {
    local entry="$1"
    local gitignore="$PARENT_DIR/.gitignore"

    if [ -f "$gitignore" ]; then
        if ! grep -q "^${entry}$" "$gitignore"; then
            echo "$entry" >> "$gitignore"
            log_success "Added $entry to .gitignore"
            CHANGES_MADE=true
        else
            log_verbose "$entry already in .gitignore"
        fi
    else
        echo "$entry" > "$gitignore"
        log_success "Created .gitignore and added $entry"
        CHANGES_MADE=true
    fi
}

setup_gitignore() {
    log_info "\nConfiguring .gitignore..."

    # Always ignore _ai.dev and .wt.conf
    add_to_gitignore "_ai.dev"
    add_to_gitignore ".wt.conf"
    add_to_gitignore "_ai.dev/.claude"

    # Add generated files if not committing them
    if [ "$COMMIT_GENERATED" = "false" ]; then
        [ "$BUILD_CLAUDE" = "true" ] && add_to_gitignore "$CLAUDE_OUTPUT"
        [ "$BUILD_AGENTS" = "true" ] && add_to_gitignore "$AGENTS_OUTPUT"
        [ "$BUILD_GEMINI" = "true" ] && add_to_gitignore "$GEMINI_OUTPUT"
    fi

    # Add .claude/ if building folders
    if [ "$BUILD_CLAUDE_FOLDERS" = "true" ]; then
        add_to_gitignore "$CLAUDE_DIR"
    fi
}

# ============================================
# WORK TRACKER CONFIGURATION
# ============================================

setup_wt_conf() {
    log_info "\nChecking .wt.conf file..."

    if [ -f "$PARENT_DIR/.wt.conf" ]; then
        log_success ".wt.conf already exists"
    else
        cat > "$PARENT_DIR/.wt.conf" << 'EOF'
# Work tracker configuration
# Auto-generated by _ai.dev/build.sh
EOF
        log_success ".wt.conf created"
        CHANGES_MADE=true
    fi
}

# ============================================
# DIRECTORY STRUCTURE SETUP
# ============================================

setup_directories() {
    log_info "\nSetting up directory structure..."

    # Create user-global _ai directory structure if it doesn't exist
    if [ ! -d "$USER_AI" ]; then
        mkdir -p "$USER_AI"
        log_success "Created ~/_ai directory"
        CHANGES_MADE=true
    fi

    # Create user-global resource type directories
    for type in "${RESOURCE_TYPES[@]}"; do
        local dir="$USER_AI/$type"
        if [ ! -d "$dir" ]; then
            mkdir -p "$dir"
            log_verbose "Created $type directory in ~/_ai/"
        fi

        # Create subdirectories for agents in user-global
        if [ "$type" = "agents" ]; then
            mkdir -p "$dir/specialized"
            mkdir -p "$dir/workflow"
            mkdir -p "$dir/protocol"
        fi
    done

    # Create _ai directory structure if it doesn't exist
    if [ ! -d "$REPO_AI" ]; then
        mkdir -p "$REPO_AI"
        log_success "Created _ai directory"
        CHANGES_MADE=true
    fi

    # Create resource type directories
    for type in "${RESOURCE_TYPES[@]}"; do
        local dir="$REPO_AI/$type"
        if [ ! -d "$dir" ]; then
            mkdir -p "$dir"
            log_verbose "Created $type directory in _ai/"
        fi

        # Create subdirectories for agents
        if [ "$type" = "agents" ]; then
            mkdir -p "$dir/specialized"
            mkdir -p "$dir/workflow"
            mkdir -p "$dir/protocol"
        fi
    done

    # Create .claude directory if building folders
    if [ "$BUILD_CLAUDE_FOLDERS" = "true" ]; then
        mkdir -p "$PARENT_DIR/$CLAUDE_DIR"
        log_verbose "Created $CLAUDE_DIR directory"
    fi
}

# ============================================
# RESOURCE DISCOVERY
# ============================================

# Discover all resources from three tiers with precedence
# Outputs: rel_path|full_path|source (one per line)
discover_resources() {
    local type=$1  # workflows, protocols, agents, commands, skills
    local temp_file=$(mktemp)

    # Scan _ai.dev (defaults) - lowest priority
    if [ -d "$DEFAULT_AI/$type" ]; then
        find "$DEFAULT_AI/$type" -type f -name "*.md" 2>/dev/null | while read -r file; do
            local rel_path="${file#$DEFAULT_AI/$type/}"
            echo "$rel_path|$file|default"
        done >> "$temp_file"
    fi

    # Scan ~/_ai (user overrides) - medium priority (overwrites defaults)
    if [ -d "$USER_AI/$type" ]; then
        find "$USER_AI/$type" -type f -name "*.md" 2>/dev/null | while read -r file; do
            local rel_path="${file#$USER_AI/$type/}"
            # Remove existing entry for this rel_path
            grep -v "^$rel_path|" "$temp_file" > "$temp_file.new" 2>/dev/null || true
            mv "$temp_file.new" "$temp_file" 2>/dev/null || true
            echo "$rel_path|$file|user" >> "$temp_file"
        done
    fi

    # Scan _ai (repo overrides) - highest priority (overwrites everything)
    if [ -d "$REPO_AI/$type" ]; then
        find "$REPO_AI/$type" -type f -name "*.md" 2>/dev/null | while read -r file; do
            local rel_path="${file#$REPO_AI/$type/}"
            # Remove existing entry for this rel_path
            grep -v "^$rel_path|" "$temp_file" > "$temp_file.new" 2>/dev/null || true
            mv "$temp_file.new" "$temp_file" 2>/dev/null || true
            echo "$rel_path|$file|repo" >> "$temp_file"
        done
    fi

    # Output the results
    cat "$temp_file" 2>/dev/null || true
    rm -f "$temp_file" "$temp_file.new" 2>/dev/null || true
}

# Get description from first line of markdown file (after heading)
get_description() {
    local file=$1
    # Try to find first non-empty line that isn't a heading
    grep -v '^#' "$file" | grep -v '^$' | head -1 | sed 's/^[[:space:]]*//' || echo ""
}

# ============================================
# CLAUDE.md GENERATION
# ============================================

generate_claude_md() {
    log_info "\nGenerating CLAUDE.md..."

    local output="$PARENT_DIR/$CLAUDE_OUTPUT"
    local temp_output="${output}.tmp"

    cat > "$temp_output" << 'HEADER'
# Claude CLI Setup

This repository uses the provider-agnostic `_ai.dev` workflow system with three-tier overrides:
- **Repository-specific**: `_ai/` (highest priority)
- **User-global**: `~/_ai/` (medium priority)
- **System defaults**: `_ai.dev/` (lowest priority)

When a file exists in multiple locations, the highest priority version is used.

---

HEADER

    # Add workflows section
    if [ "$INCLUDE_WORKFLOWS" = "true" ]; then
        cat >> "$temp_output" << 'WORKFLOWS_HEADER'
## Available Workflows

Read these workflow files to understand each development phase:

WORKFLOWS_HEADER

        discover_resources "workflows" | sort | while IFS='|' read -r rel_path file_path source; do
            [ -z "$rel_path" ] && continue
            local name="${rel_path%.md}"
            local desc=$(get_description "$file_path")
            local marker=""

            if [ "$SHOW_OVERRIDE_MARKERS" = "true" ]; then
                case "$source" in
                    repo) marker=" $OVERRIDE_MARKER_REPO" ;;
                    user) marker=" $OVERRIDE_MARKER_USER" ;;
                esac
            fi

            # Determine which path to show in the file
            local display_path="_ai.dev/workflows/$rel_path"
            [ "$source" = "user" ] && display_path="~/_ai/workflows/$rel_path"
            [ "$source" = "repo" ] && display_path="_ai/workflows/$rel_path"

            echo "- Read File: \`$display_path\`${marker}${desc:+ - $desc}" >> "$temp_output"
        done

        echo "" >> "$temp_output"
    fi

    # Add protocols section
    if [ "$INCLUDE_PROTOCOLS" = "true" ]; then
        cat >> "$temp_output" << 'PROTOCOLS_HEADER'
## Available Protocols

Read these protocol files for specific procedures:

PROTOCOLS_HEADER

        discover_resources "protocols" | sort | while IFS='|' read -r rel_path file_path source; do
            [ -z "$rel_path" ] && continue
            local name="${rel_path%.md}"
            local desc=$(get_description "$file_path")
            local marker=""

            if [ "$SHOW_OVERRIDE_MARKERS" = "true" ]; then
                case "$source" in
                    repo) marker=" $OVERRIDE_MARKER_REPO" ;;
                    user) marker=" $OVERRIDE_MARKER_USER" ;;
                esac
            fi

            local display_path="_ai.dev/protocols/$rel_path"
            [ "$source" = "user" ] && display_path="~/_ai/protocols/$rel_path"
            [ "$source" = "repo" ] && display_path="_ai/protocols/$rel_path"

            echo "- Read File: \`$display_path\`${marker}${desc:+ - $desc}" >> "$temp_output"
        done

        echo "" >> "$temp_output"
    fi

    # Add commands section
    if [ "$INCLUDE_COMMANDS" = "true" ]; then
        cat >> "$temp_output" << 'COMMANDS_HEADER'
## Available Commands

Slash commands available in Claude Code:

COMMANDS_HEADER

        discover_resources "commands" | sort | while IFS='|' read -r rel_path file_path source; do
            [ -z "$rel_path" ] && continue
            local name="${rel_path%.md}"
            local desc=$(get_description "$file_path")

            echo "- \`/$name\` - ${desc:-No description available}" >> "$temp_output"
        done

        echo "" >> "$temp_output"
    fi

    # Add footer
    cat >> "$temp_output" << 'FOOTER'
---

## Core Instructions

Read File: `_ai.dev/core-instructions.md` for the complete instruction system.

---

*This file was auto-generated by `_ai.dev/build.sh`*
*Do not edit manually - run `_ai.dev/build.sh` to regenerate*
FOOTER

    # Move temp file to final location
    mv "$temp_output" "$output"
    log_success "Generated $CLAUDE_OUTPUT"
    CHANGES_MADE=true
}

# ============================================
# AGENTS.md GENERATION (OpenAI Codex)
# ============================================

generate_agents_md() {
    log_info "\nGenerating AGENTS.md..."

    local output="$PARENT_DIR/$AGENTS_OUTPUT"

    # For now, similar to CLAUDE.md but with Codex-specific formatting
    # You can customize this later for Codex CLI specifics

    cat > "$output" << 'HEADER'
# Codex CLI Setup

This repository uses the provider-agnostic `_ai.dev` workflow system with three-tier overrides.

1. Read File: `_ai.dev/protocols/boot.md` to load the core instructions.
2. Read File: `_ai.dev/protocols/setup.md` to bootstrap the repository.
3. Read workflow files as needed.

Refer to `_ai.dev/core-instructions.md` and `_ai.dev/workflows/` for complete guidance.

---

*This file was auto-generated by `_ai.dev/build.sh`*
*Do not edit manually - run `_ai.dev/build.sh` to regenerate*
HEADER

    log_success "Generated $AGENTS_OUTPUT"
    CHANGES_MADE=true
}

# ============================================
# GEMINI.md GENERATION
# ============================================

generate_gemini_md() {
    log_info "\nGenerating GEMINI.md..."

    local output="$PARENT_DIR/$GEMINI_OUTPUT"

    cat > "$output" << 'HEADER'
# Gemini CLI Setup

This repository uses the provider-agnostic `_ai.dev` workflow system with three-tier overrides.

1. Read File: `_ai.dev/protocols/boot.md` to load the core instructions.
2. Read File: `_ai.dev/protocols/setup.md` to bootstrap the repository.
3. Read workflow files as needed.

Refer to `_ai.dev/core-instructions.md` and `_ai.dev/workflows/` for complete guidance.

---

*This file was auto-generated by `_ai.dev/build.sh`*
*Do not edit manually - run `_ai.dev/build.sh` to regenerate*
HEADER

    log_success "Generated $GEMINI_OUTPUT"
    CHANGES_MADE=true
}

# ============================================
# .CLAUDE FOLDER BUILDING
# ============================================

build_claude_folders() {
    log_info "\nBuilding .claude/ folders..."

    local claude_dir="$PARENT_DIR/$CLAUDE_DIR"
    mkdir -p "$claude_dir"

    # Build each resource type
    for type in "${RESOURCE_TYPES[@]}"; do
        local target_dir="$claude_dir/$type"

        # Skip if not included
        case "$type" in
            workflows) [ "$INCLUDE_WORKFLOWS" != "true" ] && continue ;;
            protocols) [ "$INCLUDE_PROTOCOLS" != "true" ] && continue ;;
            agents) [ "$INCLUDE_AGENTS" != "true" ] && continue ;;
            commands) [ "$INCLUDE_COMMANDS" != "true" ] && continue ;;
            skills) [ "$INCLUDE_SKILLS" != "true" ] && continue ;;
        esac

        # Create temp directory
        local temp_dir="${target_dir}.tmp"
        rm -rf "$temp_dir"
        mkdir -p "$temp_dir"

        # Copy from _ai.dev (defaults)
        if [ -d "$DEFAULT_AI/$type" ]; then
            cp -r "$DEFAULT_AI/$type/." "$temp_dir/" 2>/dev/null || true
        fi

        # Overlay from ~/_ai (user overrides)
        if [ -d "$USER_AI/$type" ]; then
            cp -rf "$USER_AI/$type/." "$temp_dir/" 2>/dev/null || true
        fi

        # Overlay from _ai (repo overrides)
        if [ -d "$REPO_AI/$type" ]; then
            cp -rf "$REPO_AI/$type/." "$temp_dir/" 2>/dev/null || true
        fi

        # Replace existing with merged
        rm -rf "$target_dir"
        mv "$temp_dir" "$target_dir"

        log_success "Built $CLAUDE_DIR/$type/"
    done

    CHANGES_MADE=true
}

# ============================================
# LEGACY SETUP.SH FUNCTIONALITY
# ============================================

setup_legacy_symlinks() {
    log_info "\nSetting up legacy symlinks (for backward compatibility)..."

    local claude_dir="$PARENT_DIR/$CLAUDE_DIR"
    local ai_dev_claude="$SCRIPT_DIR/.claude"

    # Also setup in _ai.dev directory for management mode
    mkdir -p "$ai_dev_claude"

    # Symlink agents in _ai.dev/.claude
    if [ ! -e "$ai_dev_claude/agents" ]; then
        ln -s "$SCRIPT_DIR/agents" "$ai_dev_claude/agents" 2>/dev/null || true
        log_verbose "Created symlink in _ai.dev/.claude/agents"
    fi

    # Symlink commands in _ai.dev/.claude
    if [ ! -e "$ai_dev_claude/commands" ]; then
        ln -s "$SCRIPT_DIR/commands" "$ai_dev_claude/commands" 2>/dev/null || true
        log_verbose "Created symlink in _ai.dev/.claude/commands"
    fi
}

# ============================================
# MAIN BUILD PROCESS
# ============================================

main() {
    echo "========================================="
    echo "_ai.dev Build System"
    echo "========================================="

    # Load configuration
    load_config

    # Setup basic infrastructure
    setup_wt_conf
    setup_gitignore
    setup_directories

    # Generate provider files
    [ "$BUILD_CLAUDE" = "true" ] && generate_claude_md
    [ "$BUILD_AGENTS" = "true" ] && generate_agents_md
    [ "$BUILD_GEMINI" = "true" ] && generate_gemini_md

    # Build .claude/ folders if enabled
    [ "$BUILD_CLAUDE_FOLDERS" = "true" ] && build_claude_folders

    # Setup legacy symlinks for backward compatibility
    setup_legacy_symlinks

    # Final status
    echo ""
    echo "========================================="
    if [ "$CHANGES_MADE" = true ]; then
        log_info "Build complete! Changes were made."
        echo ""
        if [ "$BUILD_CLAUDE" = "true" ]; then
            log_info "Claude Code is configured!"
            log_info "Available slash commands:"
            log_info "  /plan    - Planning orchestrator"
            log_info "  /execute - Execution orchestrator"
            log_info "  /qa      - QA orchestrator"
            log_info "  /manage  - Management orchestrator"
        fi
    else
        log_info "Build complete! Everything was already up to date."
    fi
    echo "========================================="
}

# Run main
main "$@"
