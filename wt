#!/bin/bash
# Worktree management script for Git projects
# Usage: ./wt new <name> - Creates a new worktree with branch <name>
#
# To enable bash completion, add this to your ~/.bashrc or ~/.bash_profile:
# source /path/to/your/project/wt completion

set -e

# Colors for output
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
RED='\033[0;31m'
NC='\033[0m' # No Color

# Get the main worktree directory
MAIN_DIR=$(git worktree list | head -1 | awk '{print $1}')
SCRIPT_DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )"

# Configuration defaults
START_CONTAINERS=true
PORT_OFFSET_INCREMENT=10

# Check bash version for associative array support
if [ "${BASH_VERSION%%.*}" -ge 4 ]; then
    declare -A PORT_MAP
    declare -A CONTAINER_NAME_MAP
else
    # For older bash versions, we'll use regular arrays
    PORT_MAP_KEYS=()
    PORT_MAP_VALUES=()
    CONTAINER_NAME_MAP_KEYS=()
    CONTAINER_NAME_MAP_VALUES=()
fi

# Load configuration from .wt.conf if it exists
load_config() {
    local config_file="${MAIN_DIR}/.wt.conf"
    
    if [ -f "$config_file" ]; then
        # Source the config file to load variables
        source "$config_file"
        echo -e "${GREEN}📄 Loaded config from .wt.conf${NC}"
        
        # Convert string values to boolean
        case "$(echo "$START_CONTAINERS" | tr '[:upper:]' '[:lower:]')" in
            true|yes|1) START_CONTAINERS=true ;;
            false|no|0) START_CONTAINERS=false ;;
            *) START_CONTAINERS=true ;;
        esac
        
        # Parse PORT_MAPPINGS
        if [ -n "${PORT_MAPPINGS+x}" ]; then
            if [ "${BASH_VERSION%%.*}" -ge 4 ]; then
                # Use associative array for bash 4+
                for mapping in "${PORT_MAPPINGS[@]}"; do
                    local var_name="${mapping%%:*}"
                    local base_port="${mapping#*:}"
                    PORT_MAP[$var_name]=$base_port
                done
            else
                # Use parallel arrays for older bash
                PORT_MAP_KEYS=()
                PORT_MAP_VALUES=()
                for mapping in "${PORT_MAPPINGS[@]}"; do
                    local var_name="${mapping%%:*}"
                    local base_port="${mapping#*:}"
                    PORT_MAP_KEYS+=("$var_name")
                    PORT_MAP_VALUES+=("$base_port")
                done
            fi
        fi
        
        # Parse CONTAINER_NAMES
        if [ -n "${CONTAINER_NAMES+x}" ]; then
            if [ "${BASH_VERSION%%.*}" -ge 4 ]; then
                # Use associative array for bash 4+
                for mapping in "${CONTAINER_NAMES[@]}"; do
                    local var_name="${mapping%%:*}"
                    local template="${mapping#*:}"
                    CONTAINER_NAME_MAP[$var_name]=$template
                done
            else
                # Use parallel arrays for older bash
                CONTAINER_NAME_MAP_KEYS=()
                CONTAINER_NAME_MAP_VALUES=()
                for mapping in "${CONTAINER_NAMES[@]}"; do
                    local var_name="${mapping%%:*}"
                    local template="${mapping#*:}"
                    CONTAINER_NAME_MAP_KEYS+=("$var_name")
                    CONTAINER_NAME_MAP_VALUES+=("$template")
                done
            fi
        fi
    fi
}

# Load configuration on script start (skip for completion commands)
case "${1:-}" in
    completion|completion-bash|completion-zsh)
        # Skip loading config for completion commands
        ;;
    *)
        load_config
        ;;
esac

# Helper function to get port mapping
get_port_mapping() {
    local key="$1"
    if [ "${BASH_VERSION%%.*}" -ge 4 ]; then
        echo "${PORT_MAP[$key]}"
    else
        # Search in parallel arrays
        for i in "${!PORT_MAP_KEYS[@]}"; do
            if [ "${PORT_MAP_KEYS[$i]}" = "$key" ]; then
                echo "${PORT_MAP_VALUES[$i]}"
                return
            fi
        done
    fi
}

# Helper function to get container name mapping
get_container_name_mapping() {
    local key="$1"
    if [ "${BASH_VERSION%%.*}" -ge 4 ]; then
        echo "${CONTAINER_NAME_MAP[$key]}"
    else
        # Search in parallel arrays
        for i in "${!CONTAINER_NAME_MAP_KEYS[@]}"; do
            if [ "${CONTAINER_NAME_MAP_KEYS[$i]}" = "$key" ]; then
                echo "${CONTAINER_NAME_MAP_VALUES[$i]}"
                return
            fi
        done
    fi
}

# Function to get worktree index (0 for main, 1+ for others)
get_worktree_index() {
    local worktree_name="$1"
    local project_name=$(basename "$(git rev-parse --show-toplevel)")
    
    # Get list of worktrees sorted by creation time
    local index=0
    while IFS= read -r line; do
        local wt_path=$(echo "$line" | awk '{print $1}')
        local wt_basename=$(basename "$wt_path")
        
        # Extract name from worktree path (format: project-name)
        local wt_name="${wt_basename#${project_name}-}"
        
        # Skip main worktree
        if [ "$wt_path" = "$MAIN_DIR" ]; then
            continue
        fi
        
        ((index++))
        
        if [ "$wt_name" = "$worktree_name" ]; then
            echo $index
            return
        fi
    done < <(git worktree list)
    
    # If not found, return next available index
    echo $((index + 1))
}

# Function to calculate port offset for a worktree
calculate_port_offset() {
    local worktree_name="$1"
    local index=$(get_worktree_index "$worktree_name")
    echo $((index * PORT_OFFSET_INCREMENT))
}

# Function to substitute template variables
substitute_template() {
    local template="$1"
    local worktree_name="$2"
    local worktree_index="$3"
    local result="$template"
    
    # Replace {{WORKTREE_NAME}}
    result="${result//\{\{WORKTREE_NAME\}\}/$worktree_name}"
    
    # Replace {{WORKTREE_INDEX}}
    result="${result//\{\{WORKTREE_INDEX\}\}/$worktree_index}"
    
    # Replace port placeholders
    if [ "${BASH_VERSION%%.*}" -ge 4 ]; then
        for port_var in "${!PORT_MAP[@]}"; do
            local base_port="${PORT_MAP[$port_var]}"
            local offset=$(calculate_port_offset "$worktree_name")
            local new_port=$((base_port + offset))
            result="${result//\{\{$port_var\}\}/$new_port}"
        done
    else
        for i in "${!PORT_MAP_KEYS[@]}"; do
            local port_var="${PORT_MAP_KEYS[$i]}"
            local base_port="${PORT_MAP_VALUES[$i]}"
            local offset=$(calculate_port_offset "$worktree_name")
            local new_port=$((base_port + offset))
            result="${result//\{\{$port_var\}\}/$new_port}"
        done
    fi
    
    echo "$result"
}

# Function to update environment files based on configuration
update_env_files() {
    local worktree_name="$1"
    local worktree_dir="$2"
    local port_offset=$(calculate_port_offset "$worktree_name")
    local worktree_index=$(get_worktree_index "$worktree_name")
    
    echo -e "${YELLOW}🔧 Updating configuration files for worktree...${NC}"
    
    # Process FILE_UPDATES
    if [ -n "${FILE_UPDATES+x}" ]; then
        for update in "${FILE_UPDATES[@]}"; do
            IFS='|' read -r file_path update_type update_spec <<< "$update"
            
            # Skip if we don't have all parts
            if [ -z "$file_path" ] || [ -z "$update_type" ]; then
                continue
            fi
            
            local full_path="$worktree_dir/$file_path"
            
            case "$update_type" in
                "env_vars")
                    # Add or update environment variables
                    echo "   Updating port variables in $file_path"
                    IFS=',' read -ra vars <<< "$update_spec"
                    for var_name in "${vars[@]}"; do
                        local base_port=$(get_port_mapping "$var_name")
                        if [ -n "$base_port" ]; then
                            local new_port=$((base_port + port_offset))
                            
                            # Check if variable exists in file
                            if grep -q "^${var_name}=" "$full_path" 2>/dev/null; then
                                # Update existing variable
                                sed -i.bak "s/^${var_name}=.*/${var_name}=${new_port}/" "$full_path"
                            else
                                # Add new variable
                                echo "${var_name}=${new_port}" >> "$full_path"
                            fi
                        fi
                    done
                    # Clean up backup files
                    rm -f "${full_path}.bak"
                    ;;
                    
                "replace")
                    # Replace pattern with new value
                    echo "   Applying replacements in $file_path"
                    IFS='|' read -r file_path update_type search_pattern replacement <<< "$update"
                    
                    if [ -n "$search_pattern" ] && [ -n "$replacement" ]; then
                        # Substitute templates in replacement
                        replacement=$(substitute_template "$replacement" "$worktree_name" "$worktree_index")
                        
                        # Escape special characters for sed
                        search_escaped=$(printf '%s\n' "$search_pattern" | sed 's/[[\.*^$()+?{|]/\\&/g')
                        replacement_escaped=$(printf '%s\n' "$replacement" | sed 's/[[\.*^$()+?{|]/\\&/g')
                        
                        # Perform replacement
                        sed -i.bak "s/${search_escaped}/${replacement_escaped}/g" "$full_path"
                        rm -f "${full_path}.bak"
                    fi
                    ;;
                    
                "append")
                    # Append line to file
                    echo "   Appending to $file_path"
                    local content=$(substitute_template "$update_spec" "$worktree_name" "$worktree_index")
                    echo "$content" >> "$full_path"
                    ;;
            esac
        done
    fi
    
    # Process CONTAINER_NAMES
    local has_container_names=false
    if [ "${BASH_VERSION%%.*}" -ge 4 ]; then
        [ ${#CONTAINER_NAME_MAP[@]} -gt 0 ] && has_container_names=true
    else
        [ ${#CONTAINER_NAME_MAP_KEYS[@]} -gt 0 ] && has_container_names=true
    fi
    
    if [ "$has_container_names" = true ]; then
        echo "   Setting unique container names..."
        if [ "${BASH_VERSION%%.*}" -ge 4 ]; then
            for var_name in "${!CONTAINER_NAME_MAP[@]}"; do
                local template="${CONTAINER_NAME_MAP[$var_name]}"
                local container_name=$(substitute_template "$template" "$worktree_name" "$worktree_index")
                
                # Add to .env if not exists
                if ! grep -q "^${var_name}=" "$worktree_dir/.env" 2>/dev/null; then
                    echo "${var_name}=${container_name}" >> "$worktree_dir/.env"
                else
                    sed -i.bak "s/^${var_name}=.*/${var_name}=${container_name}/" "$worktree_dir/.env"
                    rm -f "$worktree_dir/.env.bak"
                fi
            done
        else
            for i in "${!CONTAINER_NAME_MAP_KEYS[@]}"; do
                local var_name="${CONTAINER_NAME_MAP_KEYS[$i]}"
                local template="${CONTAINER_NAME_MAP_VALUES[$i]}"
                local container_name=$(substitute_template "$template" "$worktree_name" "$worktree_index")
            
                # Add to .env if not exists
                if ! grep -q "^${var_name}=" "$worktree_dir/.env" 2>/dev/null; then
                    echo "${var_name}=${container_name}" >> "$worktree_dir/.env"
                else
                    sed -i.bak "s/^${var_name}=.*/${var_name}=${container_name}/" "$worktree_dir/.env"
                    rm -f "$worktree_dir/.env.bak"
                fi
            done
        fi
    fi
    
    # Call post-update hook if defined
    if type post_env_copy_hook &>/dev/null; then
        post_env_copy_hook "$worktree_name" "$worktree_dir"
    fi
    
    echo -e "${GREEN}✅ Configuration files updated${NC}"
}

# Function to clone Docker volumes
clone_volumes() {
    if [ "$START_CONTAINERS" != true ]; then
        return 0
    fi
    
    local source_compose_project="$1"
    local dest_compose_project="$2"
    
    echo -e "${YELLOW}📦 Cloning Docker volumes from main worktree...${NC}"
    
    # Check if main worktree has running containers
    if ! docker ps | grep -q "${source_compose_project}_db"; then
        echo -e "${YELLOW}⚠️  No running database found in main worktree. Skipping volume clone.${NC}"
        echo "   To clone data later, run: ./wt clone-volumes"
        return 0
    fi
    
    # Clone PostgreSQL data using pg_dump/restore
    echo "   Cloning PostgreSQL database..."
    docker exec ${source_compose_project}-db-1 pg_dump -U web-app-db web-app-db | \
        docker exec -i ${dest_compose_project}-db-1 psql -U web-app-db web-app-db 2>/dev/null || {
        echo -e "${YELLOW}   Note: Database will be cloned after containers start${NC}"
        return 0
    }
    
    # Clone Qdrant data if exists
    if docker volume ls | grep -q "${source_compose_project}_qdrant_data"; then
        echo "   Cloning Qdrant vector data..."
        docker run --rm \
            -v ${source_compose_project}_qdrant_data:/source:ro \
            -v ${dest_compose_project}_qdrant_data:/dest \
            alpine sh -c "cp -a /source/. /dest/" 2>/dev/null || true
    fi
    
    echo -e "${GREEN}✅ Volume clone complete${NC}"
}

# Function to create a worktree (without starting containers or opening)
create_worktree() {
    local name=""
    local clone_data=true
    
    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --no-clone)
                clone_data=false
                shift
                ;;
            *)
                name="$1"
                shift
                ;;
        esac
    done
    
    if [ -z "$name" ]; then
        echo -e "${RED}Error: Please provide a name for the worktree${NC}"
        echo "Usage: ./wt create <name> [--no-clone]"
        exit 1
    fi
    
    # Get project name from current directory
    local project_name=$(basename "$(git rev-parse --show-toplevel)")
    
    # Create branch and directory names
    local branch_name="${name}"
    local worktree_dir="../${project_name}-${name}"
    
    # Check if branch already exists
    if git show-ref --verify --quiet "refs/heads/${branch_name}"; then
        echo -e "${RED}Error: Branch ${branch_name} already exists${NC}"
        exit 1
    fi
    
    # Check if directory already exists
    if [ -d "$worktree_dir" ]; then
        echo -e "${RED}Error: Directory ${worktree_dir} already exists${NC}"
        exit 1
    fi
    
    echo -e "${GREEN}🌳 Creating worktree: ${worktree_dir}${NC}"
    echo -e "${GREEN}🌿 With branch: ${branch_name}${NC}"
    
    # Create the worktree
    git worktree add "$worktree_dir" -b "$branch_name"
    
    # Change to the new worktree directory
    cd "$worktree_dir"
    
    echo -e "${YELLOW}📋 Copying environment files...${NC}"
    
    # Copy .env and node_env files from main worktree
    for env_file in ".env" "client-app/.env" "admin/.env" ".node_env" "node_env" ".node-env" "node.env"; do
        if [ -f "$MAIN_DIR/$env_file" ]; then
            echo "   Copying $env_file"
            mkdir -p "$(dirname "$env_file")"
            cp "$MAIN_DIR/$env_file" "$env_file"
        elif [ -f "${env_file}.sample" ]; then
            echo "   Creating $env_file from ${env_file}.sample"
            mkdir -p "$(dirname "$env_file")"
            cp "${env_file}.sample" "$env_file"
        fi
    done
    
    # Also check for node_env files in subdirectories
    for subdir in "client-app" "admin" "server" "api"; do
        for node_env_pattern in ".node_env" "node_env" ".node-env" "node.env"; do
            env_file="$subdir/$node_env_pattern"
            if [ -f "$MAIN_DIR/$env_file" ]; then
                echo "   Copying $env_file"
                mkdir -p "$(dirname "$env_file")"
                cp "$MAIN_DIR/$env_file" "$env_file"
            elif [ -f "${env_file}.sample" ]; then
                echo "   Creating $env_file from ${env_file}.sample"
                mkdir -p "$(dirname "$env_file")"
                cp "${env_file}.sample" "$env_file"
            fi
        done
    done
    
    # Create symlink to _ai.bws directory
    echo -e "${YELLOW}🔗 Creating symlink to _ai.bws directory...${NC}"
    if [ -d "$MAIN_DIR/_ai.bws" ]; then
        ln -s "$MAIN_DIR/_ai.bws" "_ai.bws"
        echo "   ✓ Created symlink: _ai.bws -> $MAIN_DIR/_ai.bws"
    else
        echo "   ⚠️  _ai.bws directory not found in main worktree"
    fi
    
    # Update environment files with port offsets and other configurations
    local should_update=false
    if [ "${BASH_VERSION%%.*}" -ge 4 ]; then
        [ ${#PORT_MAP[@]} -gt 0 ] || [ ${#CONTAINER_NAME_MAP[@]} -gt 0 ] && should_update=true
    else
        [ ${#PORT_MAP_KEYS[@]} -gt 0 ] || [ ${#CONTAINER_NAME_MAP_KEYS[@]} -gt 0 ] && should_update=true
    fi
    [ -n "${FILE_UPDATES+x}" ] && should_update=true
    
    if [ "$should_update" = true ]; then
        update_env_files "$name" "$worktree_dir"
    fi
    
    echo -e "${GREEN}✅ Worktree created: ${worktree_dir}${NC}"
    echo -e "${GREEN}🌿 Branch: ${branch_name}${NC}"
    echo ""
    echo "Next steps:"
    echo "  ./wt start ${name}    # Start containers"
    echo "  ./wt open ${name}     # Open tmux session"
    echo "  # OR"
    echo "  cd ${worktree_dir} && ./dev up"
}

# Function to start containers in a worktree
start_worktree() {
    local name="$1"
    
    if [ -z "$name" ]; then
        echo -e "${RED}Error: Please provide a name for the worktree${NC}"
        echo "Usage: ./wt start <name>"
        exit 1
    fi
    
    # Get project name from current directory
    local project_name=$(basename "$(git rev-parse --show-toplevel)")
    local worktree_dir="../${project_name}-${name}"
    
    if [ ! -d "$worktree_dir" ]; then
        echo -e "${RED}Error: Worktree ${worktree_dir} not found${NC}"
        echo "Use './wt create ${name}' to create it first"
        exit 1
    fi
    
    if [ "$START_CONTAINERS" = true ]; then
        echo -e "${YELLOW}🚀 Starting containers in worktree: ${name}${NC}"
        
        # Set COMPOSE_PROJECT_NAME to include worktree name
        export COMPOSE_PROJECT_NAME="${project_name}-${name}"
        
        # Change to worktree directory and start containers
        (cd "$worktree_dir" && ./dev up -d)
        
        if [ $? -eq 0 ]; then
            echo -e "${GREEN}✅ Containers started successfully${NC}"
            echo "Use './wt open ${name}' to open tmux session"
        else
            echo -e "${RED}❌ Failed to start containers${NC}"
            exit 1
        fi
    else
        echo -e "${YELLOW}🚀 Container management disabled (start-containers=false)${NC}"
        echo -e "${GREEN}✅ Worktree ready at: ${worktree_dir}${NC}"
        echo "Use './wt open ${name}' to open tmux session"
    fi
}

# Function to open tmux session for a worktree
open_worktree() {
    local name=""
    local new_tab=false
    local detached=false
    local print_command=false
    
    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --new-tab)
                new_tab=true
                shift
                ;;
            --detached)
                detached=true
                shift
                ;;
            --print-command)
                print_command=true
                shift
                ;;
            *)
                name="$1"
                shift
                ;;
        esac
    done
    
    if [ -z "$name" ]; then
        echo -e "${RED}Error: Please provide a name for the worktree${NC}"
        echo "Usage: ./wt open <name> [--new-tab] [--detached] [--print-command]"
        exit 1
    fi
    
    # Get project name from current directory
    local project_name=$(basename "$(git rev-parse --show-toplevel)")
    local worktree_dir="../${project_name}-${name}"
    local session_name="${name}"
    
    if [ ! -d "$worktree_dir" ]; then
        echo -e "${RED}Error: Worktree ${worktree_dir} not found${NC}"
        echo "Use './wt create ${name}' to create it first"
        exit 1
    fi
    
    # Print command option
    if [ "$print_command" = true ]; then
        echo "cd ${worktree_dir} && tmux attach -t ${session_name}"
        return 0
    fi
    
    # Check if tmux is available
    if ! command -v tmux &> /dev/null; then
        echo -e "${RED}Error: tmux is not installed${NC}"
        exit 1
    fi
    
    # Create tmux session if it doesn't exist
    if ! tmux has-session -t "$session_name" 2>/dev/null; then
        echo -e "${YELLOW}🖥️  Creating tmux session: ${session_name}${NC}"
        
        # Create session in the worktree directory
        tmux new-session -d -s "$session_name" -c "$worktree_dir"
        
        # Create vertical split (right pane)
        tmux split-window -h -c "$worktree_dir" -t "$session_name"
        
        # Create horizontal split in right pane (bottom right)
        tmux split-window -v -c "$worktree_dir" -t "$session_name:0.1"
        
        # Start claude in bottom right pane
        tmux send-keys -t "$session_name:0.2" "claude" C-m
        
        # Check if containers are running, if not suggest starting them
        if [ "$START_CONTAINERS" = true ]; then
            local project_name=$(basename "$(git rev-parse --show-toplevel)")
            if ! docker ps --filter "name=${project_name}-${name}" --format "{{.Names}}" | grep -q .; then
                tmux send-keys -t "$session_name:0.1" "echo 'Containers not running. Start with: ./dev up'" C-m
            fi
        fi
        
        # Select the left pane (main working area)
        tmux select-pane -t "$session_name:0.0"
    fi
    
    # Handle different opening modes
    if [ "$detached" = true ]; then
        echo -e "${GREEN}✅ Session ${session_name} is ready${NC}"
        echo "Attach with: tmux attach -t ${session_name}"
    elif [ "$new_tab" = true ]; then
        # Use iTerm AppleScript to open new tab
        if [[ "$TERM_PROGRAM" == "iTerm.app" ]] || command -v osascript &> /dev/null; then
            echo -e "${YELLOW}🆕 Opening new iTerm tab...${NC}"
            osascript <<EOF
tell application "iTerm"
    tell current window
        create tab with default profile
        tell current session of current tab
            write text "cd ${worktree_dir} && tmux attach -t ${session_name}"
        end tell
    end tell
end tell
EOF
        else
            echo -e "${YELLOW}⚠️  iTerm not detected, falling back to current terminal${NC}"
            echo -e "${GREEN}✅ Attaching to tmux session: ${session_name}${NC}"
            tmux attach-session -t "$session_name"
        fi
    else
        # Default: attach in current terminal
        echo -e "${GREEN}✅ Attaching to tmux session: ${session_name}${NC}"
        tmux attach-session -t "$session_name"
    fi
}

# Function for full workflow (create + start + open)
new_worktree() {
    local name=""
    local clone_data=true
    
    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --no-clone)
                clone_data=false
                shift
                ;;
            *)
                name="$1"
                shift
                ;;
        esac
    done
    
    if [ -z "$name" ]; then
        echo -e "${RED}Error: Please provide a name for the worktree${NC}"
        echo "Usage: ./wt new <name> [--no-clone]"
        exit 1
    fi
    
    # Create the worktree
    if [ "$clone_data" = true ]; then
        create_worktree "$name"
    else
        create_worktree "$name" --no-clone
    fi
    
    echo ""
    echo -e "${YELLOW}🚀 Starting containers...${NC}"
    start_worktree "$name"
    
    echo ""
    echo -e "${YELLOW}🖥️  Opening tmux session...${NC}"
    
    # If cloning data, set up delayed clone in tmux
    if [ "$clone_data" = true ]; then
        open_worktree "$name" --detached
        local session_name="${name}"
        tmux send-keys -t "$session_name:0.0" "echo 'Waiting for containers to start...'; sleep 10 && ./wt clone-volumes && echo 'Data cloned successfully!'" C-m
        tmux attach-session -t "$session_name"
    else
        open_worktree "$name"
    fi
}

# Function to list worktrees
list_worktrees() {
    echo -e "${GREEN}📑 Git worktrees:${NC}"
    git worktree list
}

# Function to cleanup worktree containers and volumes
cleanup_worktree() {
    local name="$1"
    local remove_worktree_dir="$2"
    
    if [ -z "$name" ]; then
        echo -e "${RED}Error: Please provide a name for the worktree to cleanup${NC}"
        echo "Usage: ./wt cleanup <name> [--remove-dir]"
        exit 1
    fi
    
    # Get project name from current directory
    local project_name=$(basename "$(git rev-parse --show-toplevel)")
    local worktree_dir="../${project_name}-${name}"
    local compose_project="${project_name}-${name}"
    
    echo -e "${YELLOW}🧹 Cleaning up worktree: ${name}${NC}"
    
    if [ "$START_CONTAINERS" = true ]; then
        # Stop and remove containers
        if [ -d "$worktree_dir" ]; then
            echo "   Stopping containers..."
            (cd "$worktree_dir" && COMPOSE_PROJECT_NAME="$compose_project" ./dev down --remove-orphans 2>/dev/null) || true
            
            # Force remove any lingering containers with the project name
            docker ps -a --filter "name=${compose_project}" --format "{{.Names}}" | while read container; do
                if [ ! -z "$container" ]; then
                    echo "   Removing container: $container"
                    docker rm -f "$container" 2>/dev/null || true
                fi
            done
        fi
        
        # Remove Docker volumes
        echo "   Removing Docker volumes..."
        docker volume ls --filter "name=${compose_project}" --format "{{.Name}}" | while read volume; do
            if [ ! -z "$volume" ]; then
                echo "   Removing volume: $volume"
                docker volume rm "$volume" 2>/dev/null || true
            fi
        done
    fi
    
    # Remove tmux session if it exists
    local session_name="${name}"
    if tmux has-session -t "$session_name" 2>/dev/null; then
        echo "   Killing tmux session: $session_name"
        tmux kill-session -t "$session_name" 2>/dev/null || true
    fi
    
    # Optionally remove worktree directory
    if [ "$remove_worktree_dir" = true ]; then
        # Remove git worktree first (this is required before we can delete the branch)
        local branch_name="${name}"
        echo "   Removing git worktree..."
        git worktree remove "$worktree_dir" --force 2>/dev/null || {
            # If the above fails, try to clean up manually
            if [ -d "$worktree_dir" ]; then
                echo "   Force removing worktree directory..."
                rm -rf "$worktree_dir"
            fi
            git worktree prune 2>/dev/null || true
        }
        
        # Now we can delete the branch
        echo "   Deleting branch: $branch_name"
        git branch -D "$branch_name" 2>/dev/null || true
    fi
    
    echo -e "${GREEN}✅ Cleanup complete for worktree: ${name}${NC}"
    
    if [ "$remove_worktree_dir" != true ]; then
        echo -e "${YELLOW}💡 Note: Worktree directory preserved. Use './wt cleanup ${name} --remove-dir' to delete it.${NC}"
    fi
}

# Function to remove a worktree (legacy function, now calls cleanup)
remove_worktree() {
    local name="$1"
    
    if [ -z "$name" ]; then
        echo -e "${RED}Error: Please provide a name for the worktree to remove${NC}"
        echo "Usage: ./wt remove <name>"
        exit 1
    fi
    
    cleanup_worktree "$name" true
}

# Function to clone volumes standalone
clone_volumes_standalone() {
    # Detect current worktree name from directory
    local current_dir=$(basename $(pwd))
    local project_name=$(basename "$(git rev-parse --show-toplevel)")
    local worktree_name=${current_dir#${project_name}-}
    
    if [ "$current_dir" = "$project_name" ]; then
        echo -e "${RED}Error: Run this command from a worktree, not the main repository${NC}"
        exit 1
    fi
    
    # Get compose project names
    local project_name=$(basename "$(git rev-parse --show-toplevel)")
    local source_project="${project_name}"
    local dest_project="${project_name}-${worktree_name}"
    
    clone_volumes "$source_project" "$dest_project"
}

# Parse cleanup command arguments
parse_cleanup_args() {
    local name=""
    local remove_dir=false
    
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --remove-dir)
                remove_dir=true
                shift
                ;;
            *)
                name="$1"
                shift
                ;;
        esac
    done
    
    cleanup_worktree "$name" "$remove_dir"
}

# Main command dispatcher
case "${1:-}" in
    create)
        shift
        create_worktree "$@"
        ;;
    start)
        shift
        start_worktree "$@"
        ;;
    open)
        shift
        open_worktree "$@"
        ;;
    new)
        shift
        new_worktree "$@"
        ;;
    list|ls)
        list_worktrees
        ;;
    remove|rm)
        shift
        remove_worktree "$@"
        ;;
    cleanup|clean)
        shift
        parse_cleanup_args "$@"
        ;;
    clone-volumes|clone)
        clone_volumes_standalone
        ;;
    completion|completion-bash)
        # Redirect stderr to avoid color code output interfering with eval
        exec 2>/dev/null
        
        # Output bash completion
        cat << 'EOF'
# Bash completion for wt command
_wt_completion() {
    local cur prev words cword
    _init_completion || return

    local commands="create start open new list ls remove rm cleanup clean clone-volumes clone"
    
    # Get list of worktree names (excluding main)
    local worktrees=""
    if command -v git &>/dev/null && git rev-parse --git-dir &>/dev/null 2>&1; then
        local project_name=$(basename "$(git rev-parse --show-toplevel)" 2>/dev/null)
        local main_dir=$(git worktree list 2>/dev/null | head -1 | awk '{print $1}')
        
        while IFS= read -r line; do
            local wt_path=$(echo "$line" | awk '{print $1}')
            local wt_basename=$(basename "$wt_path")
            
            # Skip main worktree
            if [ "$wt_path" != "$main_dir" ]; then
                # Extract name from worktree path (format: project-name)
                local wt_name="${wt_basename#${project_name}-}"
                worktrees="$worktrees $wt_name"
            fi
        done < <(git worktree list 2>/dev/null)
    fi

    case $cword in
        1)
            # Complete command names
            COMPREPLY=($(compgen -W "$commands" -- "$cur"))
            ;;
        2)
            # Complete based on the command
            case $prev in
                open|start|cleanup|clean|remove|rm)
                    # Complete with worktree names
                    COMPREPLY=($(compgen -W "$worktrees" -- "$cur"))
                    ;;
                create|new)
                    # No completion for create/new (user provides new name)
                    ;;
            esac
            ;;
        3)
            # Complete flags for specific commands
            case ${words[1]} in
                cleanup|clean)
                    COMPREPLY=($(compgen -W "--remove-dir" -- "$cur"))
                    ;;
                open)
                    COMPREPLY=($(compgen -W "--new-tab --detached --print-command" -- "$cur"))
                    ;;
                create|new)
                    COMPREPLY=($(compgen -W "--no-clone" -- "$cur"))
                    ;;
            esac
            ;;
    esac
}

# Register the completion function
complete -F _wt_completion wt
complete -F _wt_completion ./wt
EOF
        exit 0
        ;;
    completion-zsh)
        # Redirect stderr to avoid color code output interfering with eval
        exec 2>/dev/null
        
        # Output zsh completion
        cat << 'EOF'
# Zsh completion for wt command
_wt() {
    local commands worktrees
    
    commands=(
        'create:Create worktree (just directory + env files)'
        'start:Start containers in existing worktree'
        'open:Open tmux session for worktree'
        'new:Full workflow (create + start + open)'
        'list:List all worktrees'
        'remove:Remove worktree completely'
        'cleanup:Clean containers/volumes'
        'clone-volumes:Clone volumes from main worktree'
    )
    
    # Get list of worktree names (excluding main)
    worktrees=()
    if command -v git &>/dev/null && git rev-parse --git-dir &>/dev/null 2>&1; then
        local project_name=$(basename "$(git rev-parse --show-toplevel)" 2>/dev/null)
        local main_dir=$(git worktree list 2>/dev/null | head -1 | awk '{print $1}')
        
        while IFS= read -r line; do
            local wt_path=$(echo "$line" | awk '{print $1}')
            local wt_basename=$(basename "$wt_path")
            
            # Skip main worktree
            if [ "$wt_path" != "$main_dir" ]; then
                # Extract name from worktree path (format: project-name)
                local wt_name="${wt_basename#${project_name}-}"
                worktrees+=("$wt_name")
            fi
        done < <(git worktree list 2>/dev/null)
    fi
    
    case $CURRENT in
        2)
            _describe -t commands 'wt commands' commands
            ;;
        3)
            case ${words[2]} in
                open|start|cleanup|clean|remove|rm)
                    _describe -t worktrees 'worktrees' worktrees
                    ;;
                create|new)
                    # No completion for new names
                    ;;
            esac
            ;;
        4)
            case ${words[2]} in
                cleanup|clean)
                    _values 'flags' '--remove-dir[Remove worktree directory]'
                    ;;
                open)
                    _values 'flags' \
                        '--new-tab[Open in new iTerm tab]' \
                        '--detached[Create session but dont attach]' \
                        '--print-command[Just print the attach command]'
                    ;;
                create|new)
                    _values 'flags' '--no-clone[Do not clone data]'
                    ;;
            esac
            ;;
    esac
}

# Try to register completion
if type compdef >/dev/null 2>&1; then
    compdef _wt wt
    compdef _wt ./wt
fi
EOF
        exit 0
        ;;
    *)
        echo "Git Worktree Manager"
        echo ""
        echo "Commands:"
        echo "  ./wt create <name> [--no-clone]     - Create worktree (just directory + env files)"
        echo "  ./wt start <name>                   - Start containers in existing worktree"
        echo "  ./wt open <name> [options]          - Open tmux session for worktree"
        echo "  ./wt new <name> [--no-clone]        - Full workflow (create + start + open)"
        echo ""
        echo "  ./wt list                           - List all worktrees"
        echo "  ./wt cleanup <name> [--remove-dir]  - Clean containers/volumes"
        echo "  ./wt remove <name>                  - Remove worktree completely"
        echo "  ./wt clone-volumes                  - Clone volumes from main worktree"
        echo ""
        echo "Open Options:"
        echo "  ./wt open <name>                    - Open in current terminal (default)"
        echo "  ./wt open <name> --new-tab          - Open in new iTerm tab"
        echo "  ./wt open <name> --detached         - Create session but don't attach"
        echo "  ./wt open <name> --print-command    - Just print the attach command"
        echo ""
        echo "Workflow Examples:"
        echo "  # Minimal control"
        echo "  ./wt create user-auth               # Just create worktree"
        echo "  ./wt start user-auth                # Start containers when ready"
        echo "  ./wt open user-auth --new-tab       # Open in new tab"
        echo ""
        echo "  # Quick start (original behavior)"
        echo "  ./wt new user-auth                  # Everything at once"
        echo ""
        echo "Notes:"
        echo "  - Data cloning copies PostgreSQL and Qdrant data from main worktree"
        echo "  - Use 'cleanup' after merging to clean Docker resources"
        echo ""
        echo "Shell Completion:"
        echo "  # For bash - add to ~/.bashrc or ~/.bash_profile:"
        echo "  source $(realpath $0) completion-bash"
        echo "  # For zsh - add to ~/.zshrc:"
        echo "  source $(realpath $0) completion-zsh"
        echo "  # Or for current session:"
        echo "  eval \"\$(./wt completion-bash)\"  # for bash"
        echo "  eval \"\$(./wt completion-zsh)\"   # for zsh"
        exit 1
        ;;
esac